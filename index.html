<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Card Price Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/papaparse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
        }

        .control-row {
            display: flex;
            gap: 20px;
            align-items: end;
            flex-wrap: wrap;
        }

        .control-item {
            flex: 1;
            min-width: 200px;
        }

        input, select, textarea, button {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
            font-family: inherit;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            font-weight: 500;
        }

        .status.loading {
            background: #e3f2fd;
            color: #1976d2;
            border-left: 4px solid #2196f3;
        }

        .status.success {
            background: #e8f5e8;
            color: #2e7d32;
            border-left: 4px solid #4caf50;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #f44336;
        }

        .results {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }

        .result-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .result-section h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.4rem;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .card-item {
            background: linear-gradient(135deg, #f8f9ff 0%, #e8f2ff 100%);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 5px solid #667eea;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card-item:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .card-name {
            font-weight: 700;
            font-size: 1.1rem;
            color: #333;
            margin-bottom: 8px;
        }

        .card-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 0.9rem;
            color: #666;
        }

        .card-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .price-change {
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .price-increase {
            background: #ffebee;
            color: #c62828;
        }

        .price-decrease {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .results {
                grid-template-columns: 1fr;
            }
            
            .control-row {
                flex-direction: column;
            }
            
            .control-item {
                min-width: unset;
            }
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üÉè MTG Card Price Analyzer</h1>
            <p>Analyze Magic: The Gathering card price trends with real-time data from Goatbots</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <div class="control-row">
                    <div class="control-item">
                        <label for="timeframe">Time Period (months)</label>
                        <input type="number" id="timeframe" value="2" min="1" max="12">
                    </div>
                    <div class="control-item">
                        <label for="topCount">Number of Results</label>
                        <select id="topCount">
                            <option value="5">Top 5</option>
                            <option value="10" selected>Top 10</option>
                            <option value="15">Top 15</option>
                            <option value="20">Top 20</option>
                        </select>
                    </div>
                    <div class="control-item">
                        <button class="btn" id="analyzeBtn" onclick="analyzeData()">
                            <span id="btnText">üîç Analyze Data</span>
                        </button>
                    </div>
                </div>
            </div>



            <div class="control-group">
                <label for="exceptions">Card Exceptions (format: "Card Name|Edition" one per line)</label>
                <textarea id="exceptions" placeholder="Example:&#10;Lightning Bolt|Alpha&#10;Black Lotus|Beta&#10;Time Walk|Unlimited"></textarea>
            </div>

            <div id="status" class="status hidden"></div>
        </div>

        <div id="results" class="results hidden">
            <div class="result-section">
                <h3>üìà Largest Price Increases</h3>
                <div id="increases"></div>
            </div>
            <div class="result-section">
                <h3>üìâ Largest Price Decreases</h3>
                <div id="decreases"></div>
            </div>
        </div>
    </div>

    <script>
        let cardDefinitions = {};
        let priceHistory = [];
        let isAnalyzing = false;

        function showStatus(message, type = 'loading') {
            const status = document.getElementById('status');
            status.className = `status ${type}`;
            status.innerHTML = type === 'loading' ? `<div class="loading-spinner"></div>${message}` : message;
            status.classList.remove('hidden');
        }

        function hideStatus() {
            document.getElementById('status').classList.add('hidden');
        }

        async function downloadAndParseZip(url, fileName) {
            showStatus(`Downloading ${fileName}...`);
            
            // Try multiple methods to fetch the data
            const proxies = [
                '', // Direct fetch first
                'https://api.allorigins.win/raw?url=',
                'https://cors-anywhere.herokuapp.com/',
                'https://api.codetabs.com/v1/proxy?quest='
            ];
            
            for (let i = 0; i < proxies.length; i++) {
                try {
                    const proxyUrl = proxies[i] + encodeURIComponent(url);
                    const finalUrl = i === 0 ? url : proxyUrl;
                    
                    showStatus(`Downloading ${fileName}... (attempt ${i + 1}/${proxies.length})`);
                    
                    const response = await fetch(finalUrl, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/zip, application/octet-stream, */*',
                        },
                        mode: 'cors'
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const arrayBuffer = await response.arrayBuffer();
                    
                    if (arrayBuffer.byteLength === 0) {
                        throw new Error('Downloaded file is empty');
                    }
                    
                    const zip = new JSZip();
                    const zipContent = await zip.loadAsync(arrayBuffer);
                    
                    // List all files in the zip for debugging
                    const allFiles = Object.keys(zipContent.files);
                    console.log(`Files in ${fileName} zip:`, allFiles);
                    
                    // Look for any text files (not just .csv)
                    const textFiles = allFiles.filter(name => {
                        const file = zipContent.files[name];
                        return !file.dir && (
                            name.toLowerCase().endsWith('.csv') ||
                            name.toLowerCase().endsWith('.txt') ||
                            name.toLowerCase().endsWith('.tsv') ||
                            !name.includes('.') || // Files without extension
                            name.toLowerCase().includes('card') ||
                            name.toLowerCase().includes('price')
                        );
                    });
                    
                    console.log(`Text files found in ${fileName}:`, textFiles);
                    
                    if (textFiles.length === 0) {
                        // If no obvious files, try the first non-directory file
                        const nonDirFiles = allFiles.filter(name => !zipContent.files[name].dir);
                        if (nonDirFiles.length > 0) {
                            textFiles.push(nonDirFiles[0]);
                            console.log(`Using first available file: ${nonDirFiles[0]}`);
                        } else {
                            throw new Error(`No readable files found in zip archive. Files present: ${allFiles.join(', ')}`);
                        }
                    }
                    
                    const targetFile = textFiles[0];
                    const fileContent = await zipContent.files[targetFile].async('text');
                    
                    // Log first few lines to understand the format
                    const firstLines = fileContent.split('\n').slice(0, 3);
                    console.log(`First few lines of ${targetFile}:`, firstLines);
                    
                    return new Promise((resolve, reject) => {
                        // Try different delimiters
                        const delimiters = [',', '\t', ';', '|'];
                        
                        function tryParse(delimiterIndex = 0) {
                            if (delimiterIndex >= delimiters.length) {
                                reject(new Error('Unable to parse file with any common delimiter'));
                                return;
                            }
                            
                            Papa.parse(fileContent, {
                                header: true,
                                dynamicTyping: true,
                                skipEmptyLines: true,
                                delimiter: delimiters[delimiterIndex],
                                complete: (results) => {
                                    console.log(`Parse attempt with delimiter '${delimiters[delimiterIndex]}':`, {
                                        rows: results.data.length,
                                        columns: results.data[0] ? Object.keys(results.data[0]).length : 0,
                                        firstRow: results.data[0],
                                        errors: results.errors.length
                                    });
                                    
                                    if (results.errors.length > 0) {
                                        console.warn('Parse warnings:', results.errors);
                                    }
                                    
                                    if (!results.data || results.data.length === 0) {
                                        tryParse(delimiterIndex + 1);
                                        return;
                                    }
                                    
                                    // Check if we have meaningful data
                                    const firstRow = results.data[0];
                                    const columnCount = firstRow ? Object.keys(firstRow).length : 0;
                                    
                                    if (columnCount < 2) {
                                        tryParse(delimiterIndex + 1);
                                        return;
                                    }
                                    
                                    resolve(results.data);
                                },
                                error: (error) => {
                                    console.warn(`Parse error with delimiter '${delimiters[delimiterIndex]}':`, error);
                                    tryParse(delimiterIndex + 1);
                                }
                            });
                        }
                        
                        tryParse();
                    });
                    
                } catch (error) {
                    console.warn(`Attempt ${i + 1} failed:`, error.message);
                    
                    if (i === proxies.length - 1) {
                        // If all methods failed, provide detailed error message
                        let errorMessage = `Failed to download/parse ${fileName}. `;
                        
                        if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
                            errorMessage += 'This appears to be a CORS (Cross-Origin) issue. ';
                            errorMessage += 'Try: 1) Use a different browser, 2) Disable browser security temporarily, ';
                            errorMessage += '3) Use a browser extension like CORS Unblock, or 4) Deploy to a server with proxy support.';
                        } else if (error.message.includes('HTTP error')) {
                            errorMessage += 'The server returned an error. The data source might be temporarily unavailable.';
                        } else {
                            errorMessage += `Error: ${error.message}`;
                        }
                        
                        throw new Error(errorMessage);
                    }
                    
                    // Wait a bit before trying the next method
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
        }

        async function loadData() {
            try {
                // Load card definitions
                const definitions = await downloadAndParseZip(
                    'https://www.goatbots.com/download/prices/card-definitions.zip',
                    'card definitions'
                );
                
                // Create lookup map for card definitions
                cardDefinitions = {};
                definitions.forEach(card => {
                    if (card.id && card.name) {
                        cardDefinitions[card.id] = {
                            name: card.name,
                            edition: card.edition || 'Unknown',
                            foil: card.foil || false
                        };
                    }
                });
                
                showStatus('Loading price history...');
                
                // Load price history
                priceHistory = await downloadAndParseZip(
                    'https://www.goatbots.com/download/prices/price-history-2025.zip',
                    'price history'
                );
                
                showStatus(`Data loaded successfully! ${Object.keys(cardDefinitions).length} cards, ${priceHistory.length} price records`, 'success');
                
                setTimeout(hideStatus, 3000);
                
            } catch (error) {
                showStatus(`Error loading data: ${error.message}`, 'error');
                throw error;
            }
        }

        function parseExceptions() {
            const exceptionsText = document.getElementById('exceptions').value.trim();
            if (!exceptionsText) return [];
            
            return exceptionsText.split('\n')
                .map(line => line.trim())
                .filter(line => line && line.includes('|'))
                .map(line => {
                    const [name, edition] = line.split('|').map(s => s.trim());
                    return { name, edition };
                });
        }

        function shouldExcludeCard(cardName, edition, exceptions) {
            return exceptions.some(ex => 
                ex.name.toLowerCase() === cardName.toLowerCase() && 
                ex.edition.toLowerCase() === edition.toLowerCase()
            );
        }

        function calculatePriceChanges(timeframeMonths) {
            const now = new Date();
            const cutoffDate = new Date(now.getFullYear(), now.getMonth() - timeframeMonths, now.getDate());
            const exceptions = parseExceptions();
            
            // Filter price history within timeframe
            const recentPrices = priceHistory.filter(record => {
                const recordDate = new Date(record.date);
                return recordDate >= cutoffDate && record.card_id && cardDefinitions[record.card_id];
            });
            
            // Group by card
            const cardPrices = {};
            recentPrices.forEach(record => {
                const cardId = record.card_id;
                const cardInfo = cardDefinitions[cardId];
                
                if (!cardInfo || shouldExcludeCard(cardInfo.name, cardInfo.edition, exceptions)) {
                    return;
                }
                
                if (!cardPrices[cardId]) {
                    cardPrices[cardId] = {
                        ...cardInfo,
                        prices: []
                    };
                }
                
                cardPrices[cardId].prices.push({
                    date: new Date(record.date),
                    price: parseFloat(record.price) || 0
                });
            });
            
            // Calculate metrics for each card
            const results = [];
            Object.entries(cardPrices).forEach(([cardId, data]) => {
                if (data.prices.length < 2) return;
                
                // Sort prices by date
                data.prices.sort((a, b) => a.date - b.date);
                
                const firstPrice = data.prices[0].price;
                const lastPrice = data.prices[data.prices.length - 1].price;
                
                if (firstPrice === 0) return;
                
                const totalChange = ((lastPrice - firstPrice) / firstPrice) * 100;
                
                // Calculate volatility (standard deviation of price changes)
                const priceChanges = [];
                for (let i = 1; i < data.prices.length; i++) {
                    const prevPrice = data.prices[i - 1].price;
                    if (prevPrice > 0) {
                        const change = ((data.prices[i].price - prevPrice) / prevPrice) * 100;
                        priceChanges.push(change);
                    }
                }
                
                if (priceChanges.length === 0) return;
                
                const avgChange = priceChanges.reduce((sum, change) => sum + change, 0) / priceChanges.length;
                const variance = priceChanges.reduce((sum, change) => sum + Math.pow(change - avgChange, 2), 0) / priceChanges.length;
                const volatility = Math.sqrt(variance);
                
                // Count significant changes (>5% moves)
                const significantChanges = priceChanges.filter(change => Math.abs(change) > 5).length;
                
                results.push({
                    cardId,
                    name: data.name,
                    edition: data.edition,
                    foil: data.foil,
                    totalChange,
                    volatility,
                    significantChanges,
                    priceCount: data.prices.length,
                    firstPrice,
                    lastPrice,
                    // Combined score: total change weighted by consistency (repetitive changes)
                    score: Math.abs(totalChange) * (1 + (significantChanges / data.prices.length))
                });
            });
            
            return results;
        }

        function displayResults(increases, decreases) {
            const increasesDiv = document.getElementById('increases');
            const decreasesDiv = document.getElementById('decreases');
            
            increasesDiv.innerHTML = increases.map((card, index) => `
                <div class="card-item">
                    <div class="card-name">${index + 1}. ${card.name}</div>
                    <div class="card-details">
                        <div class="card-metric">
                            <span>Edition:</span>
                            <span>${card.edition}</span>
                        </div>
                        <div class="card-metric">
                            <span>Foil:</span>
                            <span>${card.foil ? 'Yes' : 'No'}</span>
                        </div>
                        <div class="card-metric">
                            <span>Price Change:</span>
                            <span class="price-change price-increase">+${card.totalChange.toFixed(1)}%</span>
                        </div>
                        <div class="card-metric">
                            <span>Volatility:</span>
                            <span>${card.volatility.toFixed(1)}%</span>
                        </div>
                        <div class="card-metric">
                            <span>Price Range:</span>
                            <span>$${card.firstPrice.toFixed(2)} ‚Üí $${card.lastPrice.toFixed(2)}</span>
                        </div>
                        <div class="card-metric">
                            <span>Significant Moves:</span>
                            <span>${card.significantChanges} of ${card.priceCount}</span>
                        </div>
                    </div>
                </div>
            `).join('');
            
            decreasesDiv.innerHTML = decreases.map((card, index) => `
                <div class="card-item">
                    <div class="card-name">${index + 1}. ${card.name}</div>
                    <div class="card-details">
                        <div class="card-metric">
                            <span>Edition:</span>
                            <span>${card.edition}</span>
                        </div>
                        <div class="card-metric">
                            <span>Foil:</span>
                            <span>${card.foil ? 'Yes' : 'No'}</span>
                        </div>
                        <div class="card-metric">
                            <span>Price Change:</span>
                            <span class="price-change price-decrease">${card.totalChange.toFixed(1)}%</span>
                        </div>
                        <div class="card-metric">
                            <span>Volatility:</span>
                            <span>${card.volatility.toFixed(1)}%</span>
                        </div>
                        <div class="card-metric">
                            <span>Price Range:</span>
                            <span>$${card.firstPrice.toFixed(2)} ‚Üí $${card.lastPrice.toFixed(2)}</span>
                        </div>
                        <div class="card-metric">
                            <span>Significant Moves:</span>
                            <span>${card.significantChanges} of ${card.priceCount}</span>
                        </div>
                    </div>
                </div>
            `).join('');
            
            document.getElementById('results').classList.remove('hidden');
        }

        async function analyzeData() {
            if (isAnalyzing) return;
            
            isAnalyzing = true;
            const btn = document.getElementById('analyzeBtn');
            const btnText = document.getElementById('btnText');
            
            btn.disabled = true;
            btnText.innerHTML = '<div class="loading-spinner"></div>Analyzing...';
            
            try {
                // Load data if not already loaded
                if (Object.keys(cardDefinitions).length === 0) {
                    await loadData();
                }
                
                showStatus('Calculating price changes...');
                
                const timeframe = parseInt(document.getElementById('timeframe').value);
                const topCount = parseInt(document.getElementById('topCount').value);
                
                const priceChanges = calculatePriceChanges(timeframe);
                
                // Sort by total change and get top increases/decreases
                const increases = priceChanges
                    .filter(card => card.totalChange > 0)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, topCount);
                
                const decreases = priceChanges
                    .filter(card => card.totalChange < 0)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, topCount);
                
                displayResults(increases, decreases);
                
                showStatus(`Analysis complete! Found ${increases.length} increases and ${decreases.length} decreases`, 'success');
                setTimeout(hideStatus, 3000);
                
            } catch (error) {
                showStatus(`Analysis failed: ${error.message}`, 'error');
            } finally {
                isAnalyzing = false;
                btn.disabled = false;
                btnText.innerHTML = 'üîç Analyze Data';
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            showStatus('Ready to analyze! Click "Analyze Data" to begin.', 'success');
            setTimeout(hideStatus, 3000);
        });
    </script>
</body>
</html>
